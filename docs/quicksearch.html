<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"gitHubServer.js.html":{"id":"gitHubServer.js.html","title":"Source: gitHubServer.js","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Source: gitHubServer.js /** * A class for authenticating and talking to the mediumroast.io backend * @author Michael Hay &lt;michael.hay@mediumroast.io&gt; * @file gitHubServer.js * @copyright 2024 Mediumroast, Inc. All rights reserved. * @license Apache-2.0 * @version 1.0.0 * * @class baseObjects * @classdesc An implementation for interacting with the GitHub backend. * * @requires GitHubFunctions * * @example * import {Companies, Interactions, Users, Billings} from './api/gitHubServer.js' * const companies = new Companies(token, org, processName) * const interactions = new Interactions(token, org, processName) * const users = new Users(token, org, processName) * const billings = new Billings(token, org, processName) * * const allCompanies = await companies.getAll() * const allInteractions = await interactions.getAll() * const allUsers = await users.getAll() * const allBillings = await billings.getAll() * * const company = await companies.findByName('myCompany') * const interaction = await interactions.findByName('myInteraction') * const user = await users.findByName('myUser') * */ // Import required modules import GitHubFunctions from './github.js' import { createHash } from 'crypto' class baseObjects { constructor(token, org, processName, objType) { this.serverCtl = new GitHubFunctions(token, org, processName) this.objType = objType this.objectFiles = { Studies: 'Studies.json', Companies: 'Companies.json', Interactions: 'Interactions.json', Users: null } } /** * @async * @function getAll * @description Get all objects from the mediumroast.io application * @returns {Array} the results from the called function mrRest class */ async getAll() { return await this.serverCtl.readObjects(this.objType) } /** * @async * @function findByName * @description Find all objects by name from the mediumroast.io application * @param {String} name - the name of the object to find * @returns {Array} the results from the called function mrRest class */ async findByName(name) { return this.findByX('name', name) } /** * @async * @function findById * @description Find all objects by id from the mediumroast.io application * @param {String} id - the id of the object to find * @param {String} endpoint - defaults to findbyx and is combined with credential and version info * @returns {Array} the results from the called function mrRest class * @deprecated */ async findById(id) { return false const fullEndpoint = '/' + this.apiVersion + '/' + this.objType + '/' + endpoint const my_obj = {findByX: \"id\", xEquals: id} return this.rest.postObj(fullEndpoint, my_obj) } /** * @async * @function findByX * @description Find all objects by attribute and value pair from the mediumroast.io application * @param {String} attribute - the attribute used to find objects * @param {String} value - the value for the defined attribute * @returns {Array} the results from the called function mrRest class */ async findByX(attribute, value, allObjects=null) { if(attribute === 'name') { value = value.toLowerCase() } // console.log(`Searching for ${this.objType} where ${attribute} = ${value}`) let myObjects = [] if(allObjects === null) { const allObjectsResp = await this.serverCtl.readObjects(this.objType) allObjects = allObjectsResp[2].mrJson } // If the length of allObjects is 0 then return an error // This will occur when there are no objects of the type in the backend if(allObjects.length === 0) { return [false, {status_code: 404, status_msg: `no ${this.objType} found`}, null] } for(const obj in allObjects) { let currentObject attribute == 'name' ? currentObject = allObjects[obj][attribute].toLowerCase() : currentObject = allObjects[obj][attribute] if(currentObject === value) { myObjects.push(allObjects[obj]) } } if (myObjects.length === 0) { return [false, {status_code: 404, status_msg: `no ${this.objType} found where ${attribute} = ${value}`}, null] } else { return [true, `SUCCESS: found all objects where ${attribute} = ${value}`, myObjects] } } /** * @async * @function createObj * @description Create objects in the mediumroast.io application * @param {Array} objs - the objects to create in the backend * @returns {Array} the results from the called function mrRest class */ // async createObj1(objs) { // return await this.serverCtl.createObjects(this.objType, objs) // } async createObj(objs) { // Create the repoMetadata object let repoMetadata = { containers: { [this.objType]: {} }, branch: {} } // Catch the container const caught = await this.serverCtl.catchContainer(repoMetadata) // If the container is locked then return the caught object if(!caught[0]) { return caught } // Get the sha for the current branch/object const sha = await this.serverCtl.getSha( this.objType, this.objectFiles[this.objType], repoMetadata.branch.name ) // If the sha is not found then return the sha object if(!sha[0]) { return sha } // Append the new object to the existing objects const mergedObjects = [...caught[2].containers[this.objType].objects, ...objs] // Write the new objects to the container const writeResp = await this.serverCtl.writeObject( this.objType, mergedObjects, repoMetadata.branch.name, sha[2] ) // If the write fails then return the writeResp if(!writeResp[0]) { return writeResp } // Release the container const released = await this.serverCtl.releaseContainer(caught[2]) // If the release fails then return the released object if(!released[0]) { return released } // Return a success message return [true, {status_code: 200, status_msg: `created [${objs.length}] ${this.objType}`}, null] } /** * @async * @function updateObj * @description Update an object in the mediumroast.io application * @param {Object} obj - the object to update in the backend which includes the id and, the attribute and value to be updated * @param {String} endpoint - defaults to findbyx and is combined with credential and version info * @returns {Array} the results from the called function mrRest class */ async updateObj(objName, key, value, dontWrite, system, whiteList) { return await this.serverCtl.updateObject(this.objType, objName, key, value, dontWrite, system, whiteList) } /** * @async * @function deleteObj * @description Delete an object in the mediumroast.io application * @param {String} id - the object to be deleted in the mediumroast.io application * @param {String} endpoint - defaults to findbyx and is combined with credential and version info * @returns {Array} the results from the called function mrRest class * @todo implment when available in the backend */ async deleteObj(objName, source, repoMetadata=null, catchIt=true) { return await this.serverCtl.deleteObject(objName, source, repoMetadata, catchIt) } /** * @async * @function linkObj * @description Link objects in the mediumroast.io application * @param {Array} objs - the objects to link in the backend * @returns {Array} the results from the called function mrRest class */ linkObj(objs) { let linkedObjs = {} for(const obj in objs) { const objName = objs[obj].name const sha256Hash = createHash('sha256').update(objName).digest('hex') linkedObjs[objName] = sha256Hash } return linkedObjs } // Create a function that checks for a locked container using the serverCtl.checkForLock() function async checkForLock() { return await this.serverCtl.checkForLock(this.objType) } } class Studies extends baseObjects { /** * @constructor * @classdesc A subclass of baseObjects that construct the study objects * @param {String} token - the token for the GitHub application * @param {String} org - the organization for the GitHub application * @param {String} processName - the process name for the GitHub application */ constructor (token, org, processName) { super(token, org, processName, 'Studies') } } // Create a subclass called Users that inherits from baseObjects class Users extends baseObjects { /** * @constructor * @classdesc A subclass of baseObjects that construct the user objects * @param {String} token - the token for the GitHub application * @param {String} org - the organization for the GitHub application * @param {String} processName - the process name for the GitHub application */ constructor (token, org, processName) { super(token, org, processName, 'Users') } // Create a new method for getAll that is specific to the Users class using getUser() in github.js async getAll() { return await this.serverCtl.getAllUsers() } // Create a new method for findMyself that is specific to the Users class using getUser() in github.js async getMyself() { return await this.serverCtl.getUser() } async findByName(name) { return this.findByX('login', name) } async findByX(attribute, value) { let myUsers = [] const allUsersResp = await this.getAll() const allUsers = allUsersResp[2] for(const user in allUsers) { if(allUsers[user][attribute] === value) { myUsers.push(allUsers[user]) } } return [true, `SUCCESS: found all users where ${attribute} = ${value}`, myUsers] } } // Create a subclass called Users that inherits from baseObjects class Billings extends baseObjects { /** * @constructor * @classdesc A subclass of baseObjects that construct the user objects * @param {String} token - the token for the GitHub application * @param {String} org - the organization for the GitHub application * @param {String} processName - the process name for the GitHub application */ constructor (token, org, processName) { super(token, org, processName, 'Billings') } // Create a new method for getAll that is specific to the Billings class using getBillings() in github.js async getAll() { const storageBillingsResp = await this.serverCtl.getStorageBillings() const actionsBillingsResp = await this.serverCtl.getActionsBillings() const allBillings = [ { resourceType: 'Storage', includedUnits: Math.abs( storageBillingsResp[2].estimated_paid_storage_for_month - storageBillingsResp[2].estimated_storage_for_month ) + ' GiB', paidUnitsUsed: storageBillingsResp[2].estimated_paid_storage_for_month + ' GiB', totalUnitsUsed: storageBillingsResp[2].estimated_storage_for_month + ' GiB' }, { resourceType: 'Actions', includedUnits: actionsBillingsResp[2].total_minutes_used + ' min', paidUnitsUsed: actionsBillingsResp[2].total_paid_minutes_used + ' min', totalUnitsUsed: actionsBillingsResp[2].total_minutes_used + actionsBillingsResp[2].total_paid_minutes_used + ' min' } ] return [true, {status_code: 200, status_msg: `found all billings`}, allBillings] } // Create a new method of to get the actions billing status only async getActionsBilling() { return await this.serverCtl.getActionsBillings() } // Create a new method of to get the storage billing status only async getStorageBilling() { return await this.serverCtl.getStorageBillings() } } class Companies extends baseObjects { /** * @constructor * @classdesc A subclass of baseObjects that construct the company objects * @param {String} token - the token for the GitHub application * @param {String} org - the organization for the GitHub application * @param {String} processName - the process name for the GitHub application */ constructor (token, org, processName) { super(token, org, processName, 'Companies') } async updateObj(objToUpdate, dontWrite=false, system=false) { // Destructure objToUpdate const { name, key, value } = objToUpdate // Define the attributes that can be updated by the user const whiteList = [ 'description', 'company_type', 'url', 'role', 'wikipedia_url', 'status', 'logo_url', 'region', 'country', 'city', 'state_province', 'zip_postal', 'street_address', 'latitude', 'longitude','phone', 'google_maps_url', 'google_news_url', 'google_finance_url','google_patents_url', 'cik', 'stock_symbol', 'stock_exchange', 'recent_10k_url', 'recent_10q_url', 'firmographic_url', 'filings_url', 'owner_tranasactions', 'industry', 'industry_code', 'industry_group_code', 'industry_group_description', 'major_group_code','major_group_description' ] return await super.updateObj(name, key, value, dontWrite, system, whiteList) } async deleteObj(objName, allowOrphans=false) { let source = { from: 'Companies', to: ['Interactions'] } // If allowOrphans is true then use the baseObjects deleteObj if(allowOrphans){ return await super.deleteObj(objName, source) } // Catch the Companies and Interaction containers // Assign repoMetadata to capture Companies nad Studies let repoMetadata = { containers: { Companies: {}, Interactions: {} }, branch: {} } const caught = await this.serverCtl.catchContainer(repoMetadata) // Use findByX to get all linkedInteractions // NOTE: This has to be done here because the company has been deleted in the next step const getCompanyObject = await this.findByX('name', objName, caught[2].containers.Companies.objects) if(!getCompanyObject[0]) { return getCompanyObject } const linkedInteractions = getCompanyObject[2][0].linked_interactions // Delete the company // Use deleteObj to delete the company const deleteCompanyObjResp = await this.serverCtl.deleteObject( objName, source, caught[2], false ) if(!deleteCompanyObjResp[0]) { return deleteCompanyObjResp } // Delete all linkedInteractions // Update source to be from the perspective of the Interactions source = { from: 'Interactions', to: ['Companies'] } // Use deleteObect to delete all linkedInteractions for(const interaction in linkedInteractions) { const deleteInteractionObjResp = await this.serverCtl.deleteObject( interaction, source, caught[2], false ) if(!deleteInteractionObjResp[0]) { return deleteInteractionObjResp } } // Release the container const relased = await this.serverCtl.releaseContainer(caught[2]) if(!relased[0]) { return relased } // Return the response return [true, {status_code: 200, status_msg: `deleted company [${objName}] and all linked interactions`}, null] } } class Interactions extends baseObjects { /** * @constructor * @classdesc A subclass of baseObjects that construct the interaction objects * @param {String} token - the token for the GitHub application * @param {String} org - the organization for the GitHub application * @param {String} processName - the process name for the GitHub application */ constructor (token, org, processName) { super(token, org, processName, 'Interactions') } async updateObj(objToUpdate, dontWrite=false, system=false) { // Destructure objToUpdate const { name, key, value } = objToUpdate // Define the attributes that can be updated by the user const whiteList = [ 'status', 'content_type', 'file_size', 'reading_time', 'word_count', 'page_count', 'description', 'abstract', 'region', 'country', 'city', 'state_province', 'zip_postal', 'street_address', 'latitude', 'longitude', 'public', 'groups' ] return await super.updateObj(name, key, value, dontWrite, system, whiteList) } async deleteObj(objName) { const source = { from: 'Interactions', to: ['Companies'] } return await super.deleteObj(objName, source) } async findByHash(hash) { return this.findByX('file_hash', hash) } } // Export classes for consumers export { Studies, Companies, Interactions, Users, Billings } × Search results Close "},"github.js.html":{"id":"github.js.html","title":"Source: github.js","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Source: github.js /** * @fileoverview A class that safely wraps RESTful calls to the GitHub API * @license Apache-2.0 * @version 1.0.0 * * @author Michael Hay &lt;michael.hay@mediumroast.io&gt; * @file github.js * @copyright 2024 Mediumroast, Inc. All rights reserved. * * @class GitHubFunctions * @classdesc Core functions needed to interact with the GitHub API for mediumroast.io. * * @requires octokit * * @exports GitHubFunctions * * @example * const gitHubCtl = new GitHubFunctions(accessToken, myOrgName, 'mr-cli-setup') * const createRepoResp = await gitHubCtl.createRepository() */ import { Octokit } from \"octokit\" class GitHubFunctions { /** * @constructor * @classdesc Core functions needed to interact with the GitHub API for mediumroast.io. * @param {String} token - the GitHub token for the mediumroast.io application * @param {String} org - the GitHub organization for the mediumroast.io application * @param {String} processName - the name of the process that is using the GitHub API * @memberof GitHubFunctions */ constructor (token, org, processName) { this.token = token this.orgName = org this.repoName = `${org}_discovery` this.repoDesc = `A repository for all of the mediumroast.io application assets.` this.octCtl = new Octokit({auth: token}) // NOTE: The lockfile name needs to be more flexible in checking for the lockfile this.lockFileName = `${processName}.lock` this.mainBranchName = 'main' this.objectFiles = { Studies: 'Studies.json', Companies: 'Companies.json', Interactions: 'Interactions.json', Users: null, Billings: null } } /** * @async * @function getSha * @description Gets the SHA of a file in a container on a branch * @param {String} containerName - the name of the container to get the SHA from * @param {String} fileName - the short name of the file to get the SHA from * @param {String} branchName - the name of the branch to get the SHA from * @returns {Array} An array with position 0 being boolean to signify success/failure, position 1 being the response or error message, and position 2 being the SHA. * @memberof GitHubFunctions */ async getSha(containerName, fileName, branchName) { try { const response = await this.octCtl.rest.repos.getContent({ owner: this.orgName, repo: this.repoName, ref: branchName, path: `${containerName}/${fileName}` }) return [true, {status_code:200, status_msg: `captured sha for [${containerName}/${fileName}]`}, response.data.sha] } catch (err) { return [false, {status_code: 500, status_msg: `unable to capture sha for [${containerName}/${fileName}] due to [${err.message}]`}, err] } } /** * @async * @function getUser * @description Gets the authenticated user from the GitHub API * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. * @todo Add a check to see if the user is a member of the organization * @todo Add a check to see if the user has admin rights to the organization */ async getUser() { // using try and catch to handle errors get user info try { const response = await this.octCtl.rest.users.getAuthenticated() return [true, `SUCCESS: able to capture current user info`, response.data] } catch (err) { return [false, `ERROR: unable to capture current user info due to [${err}]`, err.message] } } /** * @async * @function getAllUsers * @description Gets all of the users from the GitHub API * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. */ async getAllUsers() { // using try and catch to handle errors get info for all users try { const response = await this.octCtl.rest.repos.listCollaborators({ owner: this.orgName, repo: this.repoName, affiliation: 'all' }) return [true, `SUCCESS: able to capture info for all users`, response.data] } catch (err) { return [false, `ERROR: unable to capture info for all users due to [${err}]`, err.message] } } /** * @async * @function getActionsBillings * @description Gets the complete billing status for actions from the GitHub API * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. */ async getActionsBillings() { // using try and catch to handle errors get info for all billings data try { const response = await this.octCtl.rest.billing.getGithubActionsBillingOrg({ org: this.orgName, }) return [true, `SUCCESS: able to capture info for actions billing`, response.data] } catch (err) { return [false, {status_code: 404, status_msg: `unable to capture info for actions billing due to [${err}]`}, err.message] } } /** * @async * @function getStorageBillings * @description Gets the complete billing status for actions from the GitHub API * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. */ async getStorageBillings() { // using try and catch to handle errors get info for all billings data try { const response = await this.octCtl.rest.billing.getSharedStorageBillingOrg({ org: this.orgName, }) return [true, `SUCCESS: able to capture info for storage billing`, response.data] } catch (err) { return [false, {status_code: 404, status_msg: `unable to capture info for storage billing due to [${err}]`}, err.message] } } /** * @function createRepository * @description Creates a repository, at the organization level, for keeping track of all mediumroast.io assets * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the created repo or error message. * @todo Make sure the repo is not public */ async createRepository () { try { const response = await this.octCtl.rest.repos.createInOrg({ org: this.orgName, name: this.repoName, description: this.repoDesc, private: true }) return [true, response.data] } catch (err) { return[false, err.message] } } /** * @function getGitHubOrg * @description If the GitHub organization exists retrieves the detail about it and returns to the caller * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the org or error message. */ async getGitHubOrg () { try { const response = await this.octCtl.rest.orgs.get({ org: this.orgName }) return[true, response.data] } catch (err) { return[false, err.message] } } /** * @function createContainers * @description Creates the top level Study, Company and Interaction containers for all mediumroast.io assets * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the responses or error messages. */ async createContainers (containers = ['Studies', 'Companies', 'Interactions']) { let responses = [] let emptyJson = Buffer.from(JSON.stringify([])).toString('base64') for (const containerName in containers) { try { const response = await this.octCtl.rest.repos.createOrUpdateFileContents({ owner: this.orgName, repo: this.repoName, path: `${containers[containerName]}/${containers[containerName]}.json`, message: `Create container [${containers[containerName]}]`, content: emptyJson, // Create a valid empty JSON file, but this must be Base64 encoded }) responses.push(response) } catch (err) { return[false, err] } } return [true, responses] } /** * @description Creates a new branch from the main branch. * @function createBranchFromMain * @async * @returns {Promise&lt;[boolean, string, object]&gt;} A promise that resolves to an array containing a boolean indicating success, a success message, and the response from the GitHub API. * @throws {Error} If an error occurs while getting the main branch reference or creating the new branch. * @memberof GitHubFunctions */ async createBranchFromMain() { // Define the branch name const branchName = Date.now().toString() try { // Get the SHA of the latest commit on the main branch const mainBranchRef = await this.octCtl.rest.git.getRef({ owner: this.orgName, repo: this.repoName, ref: `heads/${this.mainBranchName}`, }) // Create a new branch based on the latest commit on the main branch const newBranchResp = await this.octCtl.rest.git.createRef({ owner: this.orgName, repo: this.repoName, ref: `refs/heads/${branchName}`, sha: mainBranchRef.data.object.sha, }) return [true, `SUCCESS: created branch [${branchName}]`, newBranchResp] } catch (error) { return [false, `FAILED: unable to create branch [${branchName}] due to [${error.message}]`, newBranchResp] } } /** * @description Merges a specified branch into the main branch by creating a pull request. * @function mergeBranchToMain * @async * @param {string} branchName - The name of the branch to merge into main. * @param {string} mySha - The SHA of the commit to use as the head of the pull request. * @param {string} [commitDescription='Performed CRUD operation on objects.'] - The description of the commit. * @returns {Promise&lt;[boolean, string, object]&gt;} A promise that resolves to an array containing a boolean indicating success, a success message, and the response from the GitHub API. * @throws {Error} If an error occurs while creating the branch or the pull request. * @memberof GitHubFunctions */ async mergeBranchToMain(branchName, mySha, commitDescription='Performed CRUD operation on objects.') { try { // Create a new branch // const createBranchResponse = await this.octCtl.rest.git.createRef({ // owner: this.orgName, // repo: this.repoName, // ref: branchName, // sha: mySha, // }) // console.log(createBranchResponse.data) // Create a pull request const createPullRequestResponse = await this.octCtl.rest.pulls.create({ owner: this.orgName, repo: this.repoName, title: commitDescription, head: branchName, base: this.mainBranchName, body: commitDescription, }) // Merge the pull request const mergeResponse = await this.octCtl.rest.pulls.merge({ owner: this.orgName, repo: this.repoName, pull_number: createPullRequestResponse.data.number, commit_title: commitDescription, }) return [true, 'SUCCESS: Pull request created and merged successfully', mergeResponse] } catch (error) { return [false, `FAILED: Pull request not created or merged successfully due to [${error.message}]`, null] } } /** * @description Checks to see if a container is locked. * @function checkForLock * @async * @param {string} containerName - The name of the container to check for a lock. * @returns {Promise&lt;[boolean, string]&gt;} A promise that resolves to an array containing a boolean indicating success and a message. * @throws {Error} If an error occurs while getting the latest commit or the contents of the container. * @memberof GitHubFunctions * @todo Add a check to see if the lock file is older than 24 hours and if so delete it. */ async checkForLock(containerName) { // Get the latest commit const latestCommit = await this.octCtl.rest.repos.getCommit({ owner: this.orgName, repo: this.repoName, ref: this.mainBranchName, }) // Check to see if the lock file exists const mainContents = await this.octCtl.rest.repos.getContent({ owner: this.orgName, repo: this.repoName, ref: latestCommit.data.sha, path: containerName }) // Can we search for a file with an extension of .lock? // This is due to the fact that there are other processes that may create lock files. const lockExists = mainContents.data.some( item =&gt; item.path === `${containerName}/${this.lockFileName}` ) if (lockExists) { return [true, {status_code: 200, status_msg: `container [${containerName}] is locked with lock file [${this.lockFileName}]`}, lockExists] } else { return [false, {status_code: 404, status_msg: `container [${containerName}] is not locked with lock file [${this.lockFileName}]`}, lockExists] } } /** * @description Locks a container by creating a lock file in the container. * @function lockContainer * @async * @param {string} containerName - The name of the container to lock. * @returns {Promise&lt;[boolean, string, object]&gt;} A promise that resolves to an array containing a boolean indicating success, a success message, and the response from the GitHub API. * @throws {Error} If an error occurs while getting the latest commit or creating the lock file. * @memberof GitHubFunctions */ async lockContainer(containerName) { // Define the full path to the lockfile const lockFile = `${containerName}/${this.lockFileName}` // Get the latest commit const {data: latestCommit} = await this.octCtl.rest.repos.getCommit({ owner: this.orgName, repo: this.repoName, ref: this.mainBranchName, }) let lockResponse try { lockResponse = await this.octCtl.rest.repos.createOrUpdateFileContents({ owner: this.orgName, repo: this.repoName, path: lockFile, content: '', branch: this.mainBranchName, message: `Locking container [${containerName}]`, sha: latestCommit.sha }) return [true, `SUCCESS: Locked the container [${containerName}]`, lockResponse] } catch(err) { return [false, `FAILED: Unable to lock the container [${containerName}]`, err] } } /** * @description Unlocks a container by deleting the lock file in the container. * @function unlockContainer * @async * @param {string} containerName - The name of the container to unlock. * @param {string} commitSha - The SHA of the commit to use as the head of the pull request. * @returns {Promise&lt;[boolean, string, object]&gt;} A promise that resolves to an array containing a boolean indicating success, a success message, and the response from the GitHub API. * @throws {Error} If an error occurs while getting the latest commit or deleting the lock file. * @memberof GitHubFunctions */ async unlockContainer(containerName, commitSha, branchName = this.mainBranchName) { // Define the full path to the lockfile const lockFile = `${containerName}/${this.lockFileName}` const lockExists = await this.checkForLock(containerName) // TODO: Change to try and catch if(lockExists[0]) { // NOTICE: DON'T USE DELETE AS THIS COMPLETELY REMOVES THE REPOSITORY WITHOUT MUCH WARNING const unlockResponse = await this.octCtl.rest.repos.deleteFile({ owner: this.orgName, repo: this.repoName, path: lockFile, branch: branchName, message: `Unlocking container [${containerName}]`, sha: commitSha }) return [true, `SUCCESS: Unlocked the container [${containerName}]`, unlockResponse] } else { return [false, `FAILED: Unable to unlock the container [${containerName}]`, null] } } // Create a method using the octokit called deleteBlob to delete a file from the repo async deleteBlob(containerName, fileName, branchName, sha) { // Using the github API delete a file from the container try { const deleteResponse = await this.octCtl.rest.repos.deleteFile({ owner: this.orgName, repo: this.repoName, path: `${containerName}/${fileName}`, branch: branchName, message: `Delete object [${fileName}]`, sha: sha }) // Return the delete response if the delete was successful or an error if not return [true, {status_code: 200, status_msg: `deleted object [${fileName}] from container [${containerName}]`}, deleteResponse] } catch (err) { // Return the error return [false, {status_code: 503, status_msg: `unable to delete object [${fileName}] from container [${containerName}]`}, err] } } // Create a method using the octokit to write a file to the repo async writeBlob(containerName, fileName, blob, branchName, sha) { // Only pull in the file name const fileBits = fileName.split('/') const shortFilename = fileBits[fileBits.length - 1] // Using the github API write a file to the container let octoObj = { owner: this.orgName, repo: this.repoName, path: `${containerName}/${shortFilename}`, message: `Create object [${shortFilename}]`, content: blob, branch: branchName } if(sha) { octoObj.sha = sha } try { const writeResponse = await this.octCtl.rest.repos.createOrUpdateFileContents(octoObj) // Return the write response if the write was successful or an error if not return [true, `SUCCESS: wrote object [${fileName}] to container [${containerName}]`, writeResponse] } catch (err) { // Return the error return [false, `ERROR: unable to write object [${fileName}] to container [${containerName}]`, err] } } /** * @function writeObject * @description Writes an object to a specified container using the GitHub API. * @async * @param {string} containerName - The name of the container to write the object to. * @param {object} obj - The object to write to the container. * @param {string} ref - The reference to use when writing the object. * @returns {Promise&lt;string&gt;} A promise that resolves to the response from the GitHub API. * @throws {Error} If an error occurs while writing the object. * @memberof GitHubFunctions * @todo Add a check to see if the container is locked and if so return an error. */ async writeObject(containerName, obj, ref, mySha) { // Using the github API write a file to the container try { const writeResponse = await this.octCtl.rest.repos.createOrUpdateFileContents({ owner: this.orgName, repo: this.repoName, path: `${containerName}/${this.objectFiles[containerName]}`, message: `Create object [${this.objectFiles[containerName]}]`, content: Buffer.from(JSON.stringify(obj)).toString('base64'), branch: ref, sha: mySha }) // Return the write response if the write was successful or an error if not return [true, `SUCCESS: wrote object [${this.objectFiles[containerName]}] to container [${containerName}]`, writeResponse] } catch (err) { // Return the error return [false, `ERROR: unable to write object [${this.objectFiles[containerName]}] to container [${containerName}]`, err] } } /** * @function readObjects * @description Reads objects from a specified container using the GitHub API. * @async * @param {string} containerName - The name of the container to read objects from. * @returns {Promise&lt;string&gt;} A promise that resolves to the decoded contents of the objects. * @throws {Error} If an error occurs while getting the content or parsing it. * @memberof GitHubFunctions */ async readObjects(containerName) { // Using the GitHub API get the contents of a file try { let objectContents = await this.octCtl.rest.repos.getContent({ owner: this.orgName, repo: this.repoName, ref: this.mainBranchName, path: `${containerName}/${this.objectFiles[containerName]}` }) // Decode the contents const decodedContents = Buffer.from(objectContents.data.content, 'base64').toString() // Parse the contents objectContents.mrJson = JSON.parse(decodedContents) // Return the contents return [true, `SUCCESS: read and returned [${containerName}/${this.objectFiles[containerName]}]`, objectContents] } catch (err) { // Return the error return [false, `ERROR: unable to read [${containerName}/${this.objectFiles[containerName]}]`, err] } } /** * @function updateObject * @description Reads an object from a specified container using the GitHub API. * @async * @param {string} containerName - The name of the container to read the object from. * @param {string} objName - The name of the object to update. * @param {string} key - The key of the object to update. * @param {string} value - The value to update the key with. * @param {boolean} [dontWrite=false] - A flag to indicate if the object should be written back to the container or not. * @param {boolean} [system=false] - A flag to indicate if the update is a system call or not. * @param {Array} [whiteList=[]] - A list of keys that are allowed to be updated. * @returns {Promise&lt;Array&gt;} A promise that resolves to the decoded contents of the object. * @memberof GitHubFunctions * @todo As deleteObject progresses look to see if we can improve here too */ async updateObject(containerName, objName, key, value, dontWrite=false, system=false, whiteList=[]) { // console.log(`Updating object [${objName}] in container [${containerName}] with key [${key}] and value [${value}]`) // Check to see if this is a system call or not if(!system) { // Since this is not a system call check to see if the key is in the white list if(!whiteList.includes(key)) { return [ false, { status_code: 403, status_msg: `Updating the key [${key}] is not supported.` }, null ] } } // Using the method above read the objects const readResponse = await this.readObjects(containerName) // Check to see if the read was successful if(!readResponse[0]) { return [ false, {status_code: 500, status_msg: `Unable to read source objects from GitHub.`}, readResponse ] } // Catch the container if needed let repoMetadata = { containers: {}, branch: {} } // If dontWrite is true then don't catch the container let caught = {} if(!dontWrite) { repoMetadata.containers[containerName] = {} caught = await this.catchContainer(repoMetadata) } // Loop through the objects, find and update the objects matching the name for (const obj in readResponse[2].mrJson) { if(readResponse[2].mrJson[obj].name === objName) { readResponse[2].mrJson[obj][key] = value // Update the modified date of the object const now = new Date() readResponse[2].mrJson[obj].modification_date = now.toISOString() } } // If this flag is set merely return the modified object(s) to the caller if (dontWrite) { return [ true, { status_code: 200, status_msg: `Merged updates object(s) with [${containerName}] objects.` }, readResponse[2].mrJson ] } // Call the method above to write the object const writeResponse = await this.writeObject( containerName, readResponse[2].mrJson, caught[2].branch.name, caught[2].containers[containerName].objectSha) // Check to see if the write was successful and return the error if not if(!writeResponse[0]) { return [ false, {status_code: 503, status_msg: `Unable to write the objects.`}, writeResponse ] } // Release the container const released = await this.releaseContainer(caught[2]) if(!released[0]) { return [ false, { status_code: 503, status_msg: `Cannot release the container please check [${containerName}] in GitHub.` }, released ] } // Finally return success with the results of the release return [ true, { status_code: 200, status_msg: `Updated [${containerName}] object of the name [${objName}] with [${key} = ${value}].` }, released ] } /** * @function deleteObject * @description Deletes an object from a specified container using the GitHub API. * @async * @param {string} objName - The name of the object to delete. * @param {object} source - The source object that contains the from and to containers. * @returns {Promise&lt;Array&gt;} A promise that resolves to the decoded contents of the object. * @memberof GitHubFunctions */ async deleteObject(objName, source, repoMetadata=null, catchIt=true) { // NOTE: source has a weakness we will have to remedy later, notably from can be Studies and Companies // source = { // from: 'Interactions', // to: ['Companies'] // } // Create an object that maps the from object type to the to object type fields to be updated const fieldMap = { Interactions: { Companies: 'linked_interactions', // Studies: 'linked_interactions' }, Companies: { Interactions: 'linked_companies', // Studies: 'linked_companies' }, Studies: { Interactions: 'linked_studies', Companies: 'linked_studies' } } // Catch the container if needed if(catchIt) { repoMetadata = { containers: {}, branch: {} } // Catch the container(s) repoMetadata.containers[source.from] = {} repoMetadata.containers[source.to[0]] = {} let caught = await this.catchContainer(repoMetadata) repoMetadata = caught[2] } // Loop through the from objects, find and remove the objects matching the name for (const obj in repoMetadata.containers[source.from].objects) { if(repoMetadata.containers[source.from].objects[obj].name === objName) { // If from is Interactions then we need to delete the actual file from the repo based on objName if(source.from === 'Interactions') { // Obtain the sha of the object to delete by obtaining the file name from the url attribute of the Interaction const fileName = repoMetadata.containers[source.from].objects[obj].url // Obtain the sha for fileName using octokit const { data } = await this.octCtl.rest.repos.getContent({ owner: this.orgName, repo: this.repoName, path: fileName }) // Remove the path from the file name const fileBits = fileName.split('/') const shortFilename = fileBits[fileBits.length - 1] // Call the method above to delete the object using data.sha const deleteResponse = await this.deleteBlob( source.from, shortFilename, repoMetadata.branch.name, data.sha ) // Check to see if the delete was successful and return the error if not if(!deleteResponse[0]) { return [ false, {status_code: 503, status_msg: `Unable to delete the [${source.from}] object [${objName}].`}, deleteResponse ] } } // Remove the object from the array repoMetadata.containers[source.from].objects.splice(obj, 1) } } // Loop through the to objects, find and remove objName from the linked objects and update the modification date for (const obj in repoMetadata.containers[source.to[0]].objects) { if(objName in repoMetadata.containers[source.to[0]].objects[obj][fieldMap[source.from][source.to[0]]]) { // Delete the object from the linked objects object delete repoMetadata.containers[source.to[0]].objects[obj][fieldMap[source.from][source.to[0]]][objName] // Update the modification date of the object const now = new Date() repoMetadata.containers[source.to[0]].objects[obj].modification_date = now.toISOString() } } // Call getSha to get the sha of the from object const fromSha = await this.getSha(source.from, this.objectFiles[source.from], repoMetadata.branch.name) // Check to see if the sha was captured and return the error if not if(!fromSha[0]) { return [ false, {status_code: 503, status_msg: `Unable to capture the [${source.from}] sha.`}, fromSha ] } // Call the method above to write the from objects const writeResponse = await this.writeObject( source.from, repoMetadata.containers[source.from].objects, repoMetadata.branch.name, fromSha[2]) // Check to see if the write was successful and return the error if not if(!writeResponse[0]) { console.log(writeResponse) return [ false, {status_code: 503, status_msg: `Unable to write the [${source.from}] objects.`}, writeResponse ] } // Call getSha to get the sha of the to object const toSha = await this.getSha(source.to[0], this.objectFiles[source.to[0]], repoMetadata.branch.name) // Check to see if the sha was captured and return the error if not if(!toSha[0]) { return [ false, {status_code: 503, status_msg: `Unable to capture the [${source.to[0]}] sha.`}, toSha ] } // Call the method above to write the to objects const writeResponse2 = await this.writeObject( source.to, repoMetadata.containers[source.to[0]].objects, repoMetadata.branch.name, toSha[2]) // Check to see if the write was successful and return the error if not if(!writeResponse2[0]) { return [ false, {status_code: 503, status_msg: `Unable to write the [${source.to}] objects.`}, writeResponse2 ] } // Release the container if(catchIt){ const released = await this.releaseContainer(repoMetadata) if(!released[0]) { return [ false, { status_code: 503, status_msg: `Cannot release the container please check [${source.from}] in GitHub.` }, released ] } // Finally return success with the results of the release return [ true, { status_code: 200, status_msg: `Deleted [${source.from}] object of the name [${objName}], and links in associated objects.` }, released ] } else { // Return success with the write reponses return [ true, { status_code: 200, status_msg: `Deleted [${source.from}] object of the name [${objName}], and links in associated objects.` }, [writeResponse, writeResponse2] ] } } /** * @function catchContainer * @description Catches a container by locking it, creating a new branch, reading the objects, and returning the metadata. * @param {Object} repoMetadata - The metadata object that contains the containers and branch information. * @returns {Promise&lt;Array&gt;} A promise that resolves to an array containing a boolean indicating success, a success message, and the metadata object. * @memberof GitHubFunctions */ async catchContainer(repoMetadata) { // Check to see if the containers are locked for (const container in repoMetadata.containers) { // Call the method above to check for a lock const lockExists = await this.checkForLock(container) // If the lock exists return an error if(lockExists[0]) { return [false, {status_code: 503, status_msg:`the container [${container}] is locked unable and cannot perform creates, updates or deletes on objects.`}, lockExists] } } // Lock the containers for (const container in repoMetadata.containers) { // Call the method above to lock the container const locked = await this.lockContainer(container) // Check to see if the container was locked and return the error if not if(!locked[0]) { return [false, {status_code: 503, status_msg: `unable to lock [${container}] and cannot perform creates, updates or deletes on objects.`}, locked] } // Save the lock sha repoMetadata.containers[container].lockSha = locked[2].data.content.sha } // Call the method above createBranchFromMain to create a new branch const branchCreated = await this.createBranchFromMain() // Check to see if the branch was created if(!branchCreated[0]) { return [false, {status_code: 503, status_msg: `unable to create new branch`}, branchCreated] } // Save the branch sha into containers as a separate object repoMetadata.branch = { name: branchCreated[2].data.ref, sha: branchCreated[2].data.object.sha } // Read the objects from the containers for (const container in repoMetadata.containers) { // Call the method above to read the objects const readResponse = await this.readObjects(container) // Check to see if the read was successful if(!readResponse[0]) { return [false, {status_code: 503, status_msg: `Unable to read the source objects [${container}/${this.objectFiles[container]}].`}, readResponse] } // Save the object sha into containers as a separate object repoMetadata.containers[container].objectSha = readResponse[2].data.sha // Save the objects into containers as a separate object repoMetadata.containers[container].objects = readResponse[2].mrJson } return [true,{status_code: 200, status_msg: `${repoMetadata.containers.length} containers are ready for use.`}, repoMetadata] } /** * @function releaseContainer * @description Releases a container by unlocking it and merging the branch to main. * @param {Object} repoMetadata - The metadata object that contains the containers and branch information. * @returns {Promise&lt;Array&gt;} A promise that resolves to an array containing a boolean indicating success, a success message, and the response from the GitHub API. * @memberof GitHubFunctions */ async releaseContainer(repoMetadata) { // Merge the branch to main const mergeResponse = await this.mergeBranchToMain(repoMetadata.branch.name, repoMetadata.branch.sha) // Check to see if the merge was successful and return the error if not if(!mergeResponse[0]) { return [false,{status_code:503, status_msg: `Unable to merge the branch to main.`}, mergeResponse] } // Unlock the containers by looping through them for (const container in repoMetadata.containers) { // Call the method above to unlock the container const branchUnlocked = await this.unlockContainer( container, repoMetadata.containers[container].lockSha, repoMetadata.branch.name) if(!branchUnlocked[0]) { return [false, {status_code: 503, status_msg: `Unable to unlock the container, objects may have been written please check [${container}] for objects and the lock file.`}, branchUnlocked] } // Unlock main const mainUnlocked = await this.unlockContainer( container, repoMetadata.containers[container].lockSha ) if(!mainUnlocked[0]) { return [false, {status_code: 503, status_msg: `Unable to unlock the container, objects may have been written please check [${container}] for objects and the lock file.`}, mainUnlocked] } } // Return success with number of objects written return [true, {status_code: 200, status_msg: `Released [${repoMetadata.containers.length}] containers.`}, null] } } export default GitHubFunctions × Search results Close "},"authorize.js.html":{"id":"authorize.js.html","title":"Source: authorize.js","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Source: authorize.js /** * @fileoverview This file contains the code to authorize the user to the GitHub API * @license Apache-2.0 * @version 1.0.0 * * @author Michael Hay &lt;michael.hay@mediumroast.io&gt; * @file authorize.js * @copyright 2024 Mediumroast, Inc. All rights reserved. * * @class GitHubAuth * @classdesc This class is used to authorize the user to the GitHub API * * @requires axios * @requires crypto * @requires open * @requires octoDevAuth * @requires chalk * @requires cli-table * * @exports GitHubAuth * * @example * import {GitHubAuth} from './api/authorize.js' * const github = new GitHubAuth() * const githubToken = github.getAccessToken(env) * */ import axios from \"axios\" import crypto from \"node:crypto\" import open from \"open\" import * as octoDevAuth from '@octokit/auth-oauth-device' import chalk from \"chalk\" import Table from 'cli-table' class Auth0Auth { constructor(domain, contentType, clientId, callbackUrl, state, scope) { this.domain = domain ? domain : 'dev-tfmnyye458bzcq0u.us.auth0.com' this.codePath = '/oauth/device/code' this.tokenPath = '/oauth/token' this.callbackUrl = callbackUrl ? callbackUrl : 'https://app.mediumroast.io' // this.audience = 'https://app.mediumroast.io/app' this.audience = 'mediumroast-endpoint' this.state = state ? state : 'mrCLIstate' this.scope = scope ? scope : 'companies:read' this.algorithm = 'S256' this.contentType = contentType ? contentType : 'application/x-www-form-urlencoded' // this.clientId = clientId ? clientId : 'sDflkHs3V3sg0QaZnrLEkuinXnTftkKk' this.clientId = clientId ? clientId : '0ZhDegyCotxYL8Ov9Cj4K7Z0MugtgaY0' // NOTE: Only a native app can do PKCE, question: can the native app authenticate to the API? // https://dev-tfmnyye458bzcq0u.us.auth0.com/oauth/device/code } _base64URLEncode(str) { return str.toString('base64') .replace(/\\+/g, '-') .replace(/\\//g, '_') .replace(/=/g, '') } createCodeVerifier (bytesLength=32) { const randString = crypto.randomBytes(bytesLength) return this._base64URLEncode(randString) } createChallengeCode(codeVerifier) { const codeVerifierHash = crypto.createHash('sha256').update(codeVerifier).digest() return this._base64URLEncode(codeVerifierHash) } async getDeviceCode() { const options = { method: 'POST', url: `https://${this.domain}${this.codePath}`, headers: { 'content-type': this.contentType }, data: new URLSearchParams({ client_id: this.clientId, scope: this.scope, audience: this.audience }) } let authorized try { authorized = await axios.request(options) return [true, authorized.data] } catch (err) { return [false, err] } } async openPKCEUrl(config) { // Construct the URL to build the client challenge const pkceUrl = `https://${this.domain}/authorize?` + `response_type=code&amp;` + `code_challenge=${config.challenge_code}&amp;` + `code_challenge_method=${this.algorithm}&amp;` + `client_id=${this.clientId}&amp;` + `redirect_uri=${this.callbackUrl}&amp;` + `scope='openid%20profile'&amp;` + `state=${this.state}` console.log(`URL&gt;&gt;&gt; [${pkceUrl}]`) // Call the browser const myCmd = await open(pkceUrl) } async authorizeClient(authorizationCode, codeVerifier) { const options = { method: 'POST', url: `https://${this.domain}${this.codePath}`, headers: { 'content-type': this.contentType }, data: new URLSearchParams({ // grant_type: 'urn:ietf:params:oauth:grant-type:device_code', grant_type: 'authorization_code', client_id: this.clientId, code_verifier: codeVerifier, code: authorizationCode, redirect_uri: this.callbackUrl, }) } let authorized try { authorized = await axios.request(options) return [true, authorized.data] } catch (err) { return [false, err] } } async verifyClientAuth (verificationUri) { const myCmd = await open(verificationUri) return [true, null] } async getTokens(authorizationCode, codeVerifier) { const options = { method: 'POST', url: `https://${this.domain}${this.tokenPath}`, headers: { 'content-type': this.contentType }, data: new URLSearchParams({ // grant_type: 'urn:ietf:params:oauth:grant-type:device_code', grant_type: 'authorization_code', client_id: this.clientId, code_verifier: codeVerifier, code: authorizationCode, redirect_uri: this.callbackUrl }) } let tokens try { tokens = await axios.request(options) return [true, tokens.data] } catch (err) { return [false, err] } } async getTokensDeviceCode(deviceCode) { const options = { method: 'POST', url: `https://${this.domain}${this.tokenPath}`, headers: { 'content-type': this.contentType }, data: new URLSearchParams({ grant_type: 'urn:ietf:params:oauth:grant-type:device_code', client_id: this.clientId, device_code: deviceCode }) } let tokens try { tokens = await axios.request(options) return [true, tokens.data] } catch (err) { return [false, err] } } login(env) { const token = `${env.DEFAULT.token_type} ${env.DEFAULT.access_token}` return { apiKey: token, restServer: env.DEFAULT.mr_erver, tokenType: env.DEFAULT.token_type, user: `${env.DEFAULT.first_name}&lt;${env.DEFAULT.email_address}&gt;` } } logout() { return true } decodeJWT (token) { if(token !== null || token !== undefined){ const base64String = token.split('.')[1] const decodedValue = JSON.parse( Buffer.from( base64String, 'base64') .toString('ascii') ) return decodedValue } return null } } class GitHubAuth { /** * * @param {Object} env - The environment object constructed from the configuration file * @param {String} clientType - The type of client, either 'github-app' or 'github' * @returns {Object} The access token object */ async getAccessToken(env, clientType='github-app') { // Construct the oAuth device flow object which starts the browser let deviceCode // Provide a place for the device code to be captured const deviceauth = octoDevAuth.createOAuthDeviceAuth({ clientType: clientType, clientId: env.clientId, onVerification(verifier) { deviceCode = verifier.device_code // Print the verification artifact to the console console.log( chalk.blue.bold(`If your OS supports it, opening your browser, otherwise, navigate to the Authorization website. Then, please copy and paste the Authorization code into your browser.\\n`) ) const table = new Table({ rows: [ [chalk.blue.bold(`Authorization website:`), chalk.bold.red(verifier.verification_uri)], [chalk.blue.bold(`Authorization code:`), chalk.bold.red(verifier.user_code)] ] }) console.log(table.toString()) open(verifier.verification_uri) } }) // Call GitHub to obtain the token let accessToken = await deviceauth({type: 'oauth'}) // NOTE: The token is not returned with the expires_in and expires_at fields, this is a workaround let now = new Date() now.setHours(now.getHours() + 8) accessToken.expiresAt = now.toUTCString() // Add the device code to the accessToken object accessToken.deviceCode = deviceCode return accessToken } } export {Auth0Auth, GitHubAuth} × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Global Methods &lt;async&gt; createObj(objs) Create objects in the mediumroast.io application Parameters: Name Type Description objs Array the objects to create in the backend Source: gitHubServer.js, line 125 Returns: the results from the called function mrRest class Type Array &lt;async&gt; deleteObj(id, endpoint) Delete an object in the mediumroast.io application Parameters: Name Type Description id String the object to be deleted in the mediumroast.io application endpoint String defaults to findbyx and is combined with credential and version info Source: gitHubServer.js, line 195 To Do: implment when available in the backend Returns: the results from the called function mrRest class Type Array &lt;async&gt; findById(id, endpoint) Find all objects by id from the mediumroast.io application Parameters: Name Type Description id String the id of the object to find endpoint String defaults to findbyx and is combined with credential and version info Deprecated: Yes Source: gitHubServer.js, line 71 Returns: the results from the called function mrRest class Type Array &lt;async&gt; findByName(name) Find all objects by name from the mediumroast.io application Parameters: Name Type Description name String the name of the object to find Source: gitHubServer.js, line 60 Returns: the results from the called function mrRest class Type Array &lt;async&gt; findByX(attribute, value) Find all objects by attribute and value pair from the mediumroast.io application Parameters: Name Type Description attribute String the attribute used to find objects value String the value for the defined attribute Source: gitHubServer.js, line 87 Returns: the results from the called function mrRest class Type Array &lt;async&gt; getAll() Get all objects from the mediumroast.io application Source: gitHubServer.js, line 50 Returns: the results from the called function mrRest class Type Array &lt;async&gt; linkObj(objs) Link objects in the mediumroast.io application Parameters: Name Type Description objs Array the objects to link in the backend Source: gitHubServer.js, line 208 Returns: the results from the called function mrRest class Type Array &lt;async&gt; updateObj(obj, endpoint) Update an object in the mediumroast.io application Parameters: Name Type Description obj Object the object to update in the backend which includes the id and, the attribute and value to be updated endpoint String defaults to findbyx and is combined with credential and version info Source: gitHubServer.js, line 183 Returns: the results from the called function mrRest class Type Array × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Modules Classes baseObjects Billings Companies GitHubFunctions Interactions Studies Users × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Classes Classes baseObjects Billings Companies GitHubFunctions Interactions Studies Users × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Tutorials Classes baseObjects Billings Companies GitHubFunctions Interactions Studies Users × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj mediumroast_js 0.4.48 Welcome to Open Source Mediumroast for GitHub. Products organizations must build robust product plans from competitive and customer interactions everyone can see, use, and reference. Therefore, Mediumroast for GitHub intends to help Products oranizations construct an active interactions repository close to the action of development and issue management in GitHub. Notice: You can review the GitHub Page Version rather than the repository version of this documentation, but the screencasts of several of the CLI tutorials will not display. Installation and configuration Mediumroast for GitHub includes a GitHub Application, a Command Line Interface, and a Software Development Kit. The following steps show you how to install the App and the CLI with SDK. Preinstallation requirements A GitHub organization, please Permissions in your GitHub organization to install a GitHub application. Access to a command line terminal on Linux or MacOS. Node.js installed, ideally globally for all users. NPM installed, ideally globally for all users. Step 1 - Install the GitHub App Browse to the Mediumroast for GitHub GitHub Application and: Click install, Choose the location for the installation, usually your organization, Confirm the requested permissions, and Browse to your organization's Settings &gt; Third-Party Access &gt; GitHub Apps and confirm that Mediumroast for GitHub is installed. Step 2 - Install mediumroast_js This package mediumroast_js can be installed and removed via npm, several ways to install follow. For Linux and MacOS Assuming the preinstallation requirements, installation of node.js and npm, are met please one one of the following. Global installation for all users: sudo npm i -g mediumroast_js Local installation for a developer or single user: npm i mediumroast_js For WinOS Coming soon. Step 3 - Setup the CLI Before you can use the Mediumroast for GitHub CLI the environment must be setup. With the CLI installed please run mrcli setup to start the setup process, note there's a video of the setup process in CLI README. What's provided Running mrcli setup creates a repository in your oganization called &lt;organization_name&gt;_discovery for all interactions and objects, creates two intitial companies, and installs two GitHub Actions to control the number of branches and provide some basic out of the box reporting -- see example screenshot below. Warning Since Mediumroast for GitHub creates a regular repository you can interact with it as normal, but doing so is not recommended. If you interact with the repository, in regular ways, this could result in Mediumroast for GitHub becoming inoperable. There are cases where it may become necessary to directly work with the repository, but that should be rare. Example screenshot of in repository companies report Issues If you detect a problem or want to suggest an improvement open an issue and we will work with you to resolve or respond. × Search results Close "},"baseObjects.html":{"id":"baseObjects.html","title":"Class: baseObjects","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Class: baseObjects baseObjects An implementation for interacting with the GitHub backend. new baseObjects() gitHubServer.js Version: 1.0.0 Author: Michael Hay Copyright: 2024 Mediumroast, Inc. All rights reserved. License: Apache-2.0 Source: gitHubServer.js, line 1 Requires: module:GitHubFunctions Example import {Companies, Interactions, Users, Billings} from './api/gitHubServer.js' const companies = new Companies(token, org, processName) const interactions = new Interactions(token, org, processName) const users = new Users(token, org, processName) const billings = new Billings(token, org, processName) const allCompanies = await companies.getAll() const allInteractions = await interactions.getAll() const allUsers = await users.getAll() const allBillings = await billings.getAll() const company = await companies.findByName('myCompany') const interaction = await interactions.findByName('myInteraction') const user = await users.findByName('myUser') Requires module:GitHubFunctions × Search results Close "},"Billings.html":{"id":"Billings.html","title":"Class: Billings","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Class: Billings Billings A subclass of baseObjects that construct the user objects new Billings(token, org, processName) Parameters: Name Type Description token String the token for the GitHub application org String the organization for the GitHub application processName String the process name for the GitHub application Source: gitHubServer.js, line 296 × Search results Close "},"Companies.html":{"id":"Companies.html","title":"Class: Companies","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Class: Companies Companies A subclass of baseObjects that construct the company objects new Companies(token, org, processName) Parameters: Name Type Description token String the token for the GitHub application org String the organization for the GitHub application processName String the process name for the GitHub application Source: gitHubServer.js, line 343 × Search results Close "},"GitHubFunctions.GitHubFunctions.html":{"id":"GitHubFunctions.GitHubFunctions.html","title":"Class: GitHubFunctions","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Class: GitHubFunctions GitHubFunctions Core functions needed to interact with the GitHub API for mediumroast.io. new GitHubFunctions(token, org, processName) Parameters: Name Type Description token String the GitHub token for the mediumroast.io application org String the GitHub organization for the mediumroast.io application processName String the name of the process that is using the GitHub API Source: github.js, line 34 × Search results Close "},"Interactions.html":{"id":"Interactions.html","title":"Class: Interactions","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Class: Interactions Interactions A subclass of baseObjects that construct the interaction objects new Interactions(token, org, processName) Parameters: Name Type Description token String the token for the GitHub application org String the organization for the GitHub application processName String the process name for the GitHub application Source: gitHubServer.js, line 446 × Search results Close "},"module-GitHubAuth.html":{"id":"module-GitHubAuth.html","title":"Module: GitHubAuth","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Module: GitHubAuth authorize.js Version: 1.0.0 Author: Michael Hay Copyright: 2024 Mediumroast, Inc. All rights reserved. License: Apache-2.0 Source: authorize.js, line 1 Example import {GitHubAuth} from './api/authorize.js' const github = new GitHubAuth() const githubToken = github.getAccessToken(env) Requires module:axios module:crypto module:open module:octoDevAuth module:chalk module:cli-table × Search results Close "},"module-GitHubFunctions.html":{"id":"module-GitHubFunctions.html","title":"Module: GitHubFunctions","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Module: GitHubFunctions github.js Version: 1.0.0 Author: Michael Hay Copyright: 2024 Mediumroast, Inc. All rights reserved. License: Apache-2.0 Source: github.js, line 1 Example const gitHubCtl = new GitHubFunctions(accessToken, myOrgName, 'mr-cli-setup') const createRepoResp = await gitHubCtl.createRepository() Requires module:octokit Methods &lt;inner&gt; createContainers() Creates the top level Study, Company and Interaction containers for all mediumroast.io assets Source: github.js, line 186 Returns: An array with position 0 being boolean to signify success/failure and position 1 being the responses or error messages. Type Array &lt;inner&gt; createRepository() Creates a repository, at the organization level, for keeping track of all mediumroast.io assets Source: github.js, line 150 To Do: Make sure the repo is not public Returns: An array with position 0 being boolean to signify success/failure and position 1 being the created repo or error message. Type Array &lt;async, inner&gt; getActionsBillings() Gets the complete billing status for actions from the GitHub API Source: github.js, line 114 Returns: An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. Type Array &lt;async, inner&gt; getAllUsers() Gets all of the users from the GitHub API Source: github.js, line 94 Returns: An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. Type Array &lt;inner&gt; getGitHubOrg() If the GitHub organization exists retrieves the detail about it and returns to the caller Source: github.js, line 170 Returns: An array with position 0 being boolean to signify success/failure and position 1 being the org or error message. Type Array &lt;async, inner&gt; getStorageBillings() Gets the complete billing status for actions from the GitHub API Source: github.js, line 132 Returns: An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. Type Array &lt;async, inner&gt; getUser() Gets the authenticated user from the GitHub API Source: github.js, line 76 To Do: Add a check to see if the user is a member of the organization Add a check to see if the user has admin rights to the organization Returns: An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. Type Array × Search results Close "},"Studies.html":{"id":"Studies.html","title":"Class: Studies","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Class: Studies Studies A subclass of baseObjects that construct the study objects new Studies(token, org, processName) Parameters: Name Type Description token String the token for the GitHub application org String the organization for the GitHub application processName String the process name for the GitHub application Source: gitHubServer.js, line 240 × Search results Close "},"Users.html":{"id":"Users.html","title":"Class: Users","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Class: Users Users A subclass of baseObjects that construct the user objects new Users(token, org, processName) Parameters: Name Type Description token String the token for the GitHub application org String the organization for the GitHub application processName String the process name for the GitHub application Source: gitHubServer.js, line 254 × Search results Close "},"tutorial-Company.html":{"id":"tutorial-Company.html","title":"Tutorial: Company Subcommand","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Company Subcommand Companies Company objects are central to Mediumroast for GitHub. Interaction sand in the future Studies rely on Companies to function. After setup is run, via mrcli setup, two companies are present to work with. Additional Companies can be added, updated, or removed; essentially, company is an mrcli sub-command that affords users Create, Read, Update and Delete capabilities. Each of the major functions for mrcli company are described in this document. Notice Some of the command line options and switches may not yet be implemented; therefore, if a switch or option is not yet implemented the CLI will inform the user and then exit. Help Prints the usage for the company sub-command and exits. Command(s) run mrcli company --help Screenshot with output List company objects Print out one or more Companies to the command line or an alternative output mechanism like a CSV file. Filtering can be applied to find Companies with specific attributes. List all company objects in a table format This is the default output when running mrcli c or mrcli company which prints a text table to STDOUT. Command(s) run mrcli c mrcli company Screenshot with output List all company objects in JSON format Output a list of company objects in properly formatted JSON to STDOUT which can be viewed, redirected to a file, or piped to another command. Command(s) run mrcli c --output=json mrcli company --output=json Screenshot with output List all company objects and output to a CSV or XLSX Company data can be output in either a CSV or XLSX files to enable consumption in common tools like Microsoft Excel. The resulting files will be stored in $HOME/Documents directory as Mr_Companies.csv or Mr_Companies.xlsx depending on your intended output. Command(s) run mrcli c --output=csv mrcli c --output=xls Screenshot of commands being run Screenshot of CSV imported into MacOS numbers Filter company outputs The CLI offers the ability to filter outputs by almost any company attribute. This is manifest by two switches on the company sub-command one specific to finding companies by name, --find_by_name and the other by an arbitrary attribute, --find_by_x. Note all output format options, like JSON, CSV, etc., are available when the outputs are filtered. Finally, only exact matches are supported, meaning if you want to search for a company using any attribute you have to fully provide the attribute's value (i.e., \"Med\" would not match \"Mediumroast, Inc.\", but \"Mediumroast, Inc.\" would). Filter in a company by name To zero in on a specific company using the find by name switch is provided. Command(s) run mrcli c --find_by_name=\"Mediumroast, Inc.\" Screenshot with output Filter a company by attribute Find a specific company by a particular attribute in the example below the switch filters on the attribute company_type. Command(s) run mrcli c --find_by_x='{\"company_type\": \"Public\"}' Screenshot with output Update a company attribute To update a company attribute the --update switch is provided. A properly formatted JSON stanza is supplied to the --update switch that specifies the name of the company to update, the key to update, and finally the value of the key to update. Command(s) run mrcli c --update='{\"name\": \"Atlassian Corp\", \"key\": \"company_type\", \"value\": \"Public\"}' Screencast with output Notice: Only the markdown version rendered through the GitHub web interface will display the screencast. If you're viewing these files through the GitHub Page Version the link below will just show up as text. https://github.com/mediumroast/mediumroast_js/assets/10818650/a74cb8cd-f8cb-4a8d-8968-ccf9b875d86b Delete a company Remove a company and associated interactions if in the repository. There is a confirmation prompt which defaults to yes. Note that the exact company name is needed to proceed with a deletion. Command(s) run mrcli c --delete=\"Atlassian Corp\" Screenshot with output Add a company A command line prompt based wizard steps the user through either a semi-automated process or a fully-automated process to define a company. The semi-automated process is typically used for companies that aren't public. While the fully-automated process is typically used for companies that are public. In either case the user is asked to verify the steps taken before the company is committed to the repository. Command(s) run mrcli c --add_wizard Screenshot with output × Search results Close "},"tutorial-Interaction.html":{"id":"tutorial-Interaction.html","title":"Tutorial: Interaction Subcommand","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Interaction Subcommand Interactions After running mrcli setup you can start adding Interactions. An Interaction can be as simple as an email thread between an account team and a customer, a detailed customer interview or even documentation about a competitor. Additional Interactions can be added, updated, or removed; essentially, interaction is an mrcli sub-command that affords users Create, Read, Update and Delete capabilities. Each of the major functions for mrcli interaction are described in this document. Notice Some of the command line options and switches may not yet be implemented; therefore, if a switch or option is not yet implemented the CLI will inform the user and then exit. Help Prints the usage for the interaction sub-command and exits. Command(s) run mrcli interaction --help Screenshot with output List interaction objects Print out one or more Interaction to the command line or an alternative output mechanism like a CSV file. Filtering can be applied to find Interactions with specific attributes. List all interaction objects in a table format This is the default output when running mrcli i or mrcli interaction which prints a text table to STDOUT. Command(s) run mrcli i mrcli interaction Screenshot with output List all interaction objects in JSON format Output a list of company objects in properly formatted JSON to STDOUT which can be viewed, redirected to a file, or piped to another command. Command(s) run mrcli i --output=json mrcli interaction --output=json Screenshot with output List all interaction objects and output to a CSV or XLSX Interaction data can be output in either a CSV or XLSX files to enable consumption in common tools like Microsoft Excel. The resulting files will be stored in $HOME/Documents directory as Mr_Interactions.csv or Mr_Interactions.xlsx depending on your intended output. Command(s) run mrcli i --output=csv mrcli i --output=xls Screenshot of commands being run Screenshot of CSV imported into MacOS numbers Filter interaction outputs The CLI offers the ability to filter outputs by almost any interaction attribute. This is manifest by two switches on the interaction sub-command one specific to finding Interactions by name, --find_by_name and the other by an arbitrary attribute, --find_by_x. Note all output format options, like JSON, CSV, etc., are available when the outputs are filtered. Finally, only exact matches are supported, meaning if you want to search for a interaction using any attribute you have to fully provide the attribute's value (i.e., \"The\" would not match \"The 7 Strategic Phases of the Product Planning Process\" , but \"The 7 Strategic Phases of the Product Planning Process\" would). Filter in a interaction by name To zero in on a specific interaction using the find by name switch is provided. Command(s) run mrcli i --find_by_name=\"The 7 Strategic Phases of the Product Planning Process\" Screenshot with output Filter an interaction by attribute Find a specific interaction by a particular attribute in the example below the switch filters on the attribute city. Command(s) run mrcli i --find_by_x='{\"city\": \"Santa Barbara\"}' Screenshot with output Update an interaction attribute To update an interaction attribute the --update switch is provided. A properly formatted JSON stanza is supplied to the --update switch that specifies the name of the interaction to update, the key to update, and finally the value of the key to update. Command(s) run mrcli c --update='{\"name\": \"Atlassian Corp\", \"key\": \"company_type\", \"value\": \"Public\"}' Screencast with output Notice: Only the markdown version rendered through the GitHub web interface will display the screencast. If you're viewing these files through the GitHub Page Version the link below will just show up as text. https://github.com/mediumroast/mediumroast_js/assets/10818650/e11256e7-28ca-47d5-b131-58a2036671a6 Delete an interaction Remove a company and associated interactions if in the repository. There is a confirmation prompt which defaults to yes. Note that the exact company name is needed to proceed with a deletion. Command(s) run mrcli i --delete=\"Atlassian Corp\" Screenshot with output Add an interaction A command line prompt based wizard steps the user through a semi-automated process process to define an interaction. The user is asked to verify the steps taken before the interaction(s) is committed to the repository. Command(s) run mrcli i --add_wizard Screencast with output Notice: Only the markdown version rendered through the GitHub web interface will display the screencast. If you're viewing these files through the GitHub Page Version the link below will just show up as text. https://github.com/mediumroast/mediumroast_js/assets/10818650/0b28db90-d6ba-4224-a9ae-4c301c2b9614 × Search results Close "},"tutorial-README.html":{"id":"tutorial-README.html","title":"Tutorial: Administrative Subcommands","body":" Mediumroast for GitHub SDK Modules GitHubAuthGitHubFunctions Classes baseObjectsBillingsCompaniesGitHubFunctions.GitHubFunctionsInteractionsStudiesUsers Tutorials Company SubcommandInteraction SubcommandAdministrative Subcommands Global createObjdeleteObjfindByIdfindByNamefindByXgetAlllinkObjupdateObj Administrative Subcommands Mediumroast for GitHub CLI (Command Line Interface) The CLI is divided into two sets one for administrative interactions with the system and another for interacting with Mediumroast for GitHub objects like Companies and Interactions. This document covers both the administrative CLI and makes reference to the CLI set for Mediumroast for GitHub objects. Administrative CLIs To enable setup and operational reporting of Mediumroast for GitHub several CLIs are available, each is described below. User reporting Reports on all users who can access the repository that contains the Mediumroast for GitHub. A screenshot showing the usage information and outputs for major functions is included below, and notice, user names and other personally identifiable information has been redacted from the screenshot below. Command(s) run mrcli u mrcli u --my_user Screenshot with ouput Billing reporting Provides reports for consumed actions and repository storage consumed by the organization that has installed and is using Mediumroast for GitHub. A screenshot showing the usage information and outputs for major functions is included below. Command(s) run mrcli b mrcli b --storage mrcli b --actions Screenshot with ouput Setup To help users quickly get on board with Mediumroast for GitHub the setup CLI is used. This CLI creates the ${HOME}/.mediumroast/config.ini file, creates the repository including key directories, and creates two initial companies. A screencast video showing the process for setting up the CLI environment and creating two companies is available below. Command(s) run mrcli setup Screencast showing setup process Notice: Only the markdown version rendered through the GitHub web interface will display the screencast. If you're viewing these files through the GitHub Page Version the link below will just show up as text. https://github.com/mediumroast/mediumroast_js/assets/10818650/68c08502-4f59-4981-a001-0d9c9bd1d4d2 [Company Subcommand] | [Interaction Subcommand] × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
